(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{552:function(a,t,e){"use strict";e.r(t);var n=e(12),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"定义-es6-允许按照一定模式-从数组和对象中提取值-对变量进行赋值-这被称为解构-destructuring-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义-es6-允许按照一定模式-从数组和对象中提取值-对变量进行赋值-这被称为解构-destructuring-。"}},[a._v("#")]),a._v(" 定义：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。")]),a._v(" "),e("h4",{attrs:{id:"数组的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组的解构赋值"}},[a._v("#")]),a._v(" 数组的解构赋值")]),a._v(" "),e("ol",[e("li",[a._v("本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const a = [1,2,3];\nconst [b,c,d] = a;\nconsole.log(b,c,d); // 1,2,3\n\nlet g,f\n[g,f] = a\nconsole.log(g,f); // 1,2\n\n\nlet g = [2,[1,[3]]]\nlet ga,gb,gc\n[ga,[gb,[gc]]] = g\nconsole.log(ga,gb,gc) // 2 1 3\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[a._v("匹配不到时，赋值undefined")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [foo] = [];\nlet [bar, foo] = [1];\n// 两个foo都是undefined\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[a._v("有iterator接口的，都可以采用数组形式解构赋值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x, y, z] = new Set(['a', 'b', 'c']);\nx // \"a\"\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[a._v("允许设置默认值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [foo = true] = [];\nfoo // true\n\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n\n")])])]),e("p",[a._v("注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n")])])]),e("h4",{attrs:{id:"对象的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的解构赋值"}},[a._v("#")]),a._v(" 对象的解构赋值")]),a._v(" "),e("ol",[e("li",[a._v("注意：组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let { bar, foo } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nlet { baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // undefined\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[a._v("如果匹配失败/解构失败，变量的值等于undefined。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let {foo} = {bar: 'baz'};\nfoo // undefined\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[a._v("以上写法，其实是变量名与属性名一样的写法。如果变量名与属性名不一致，必须写成下面这样。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n")])])]),e("p",[a._v("这实际上说明，对象的解构赋值是下面形式的简写。也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[a._v("嵌套对象解构")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n\n// 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[a._v("也可以设置默认值，条件同样是对象的属性值严格等于undefined。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var {x: y = 3} = {};\ny // 3\n")])])]),e("ol",{attrs:{start:"6"}},[e("li",[a._v("先声明，后解构的注意事项")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n\n\n// 正确的写法\nlet x;\n({x} = {x: 1});\n\n//  上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。\n")])])]),e("h3",{attrs:{id:"字符串解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串解构赋值"}},[a._v("#")]),a._v(" 字符串解构赋值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('const [a, b, c, d, e] = \'hello\';\na // "h"\nb // "e"\nc // "l"\nd // "l"\ne // "o"\n\n//  字符串被转换成了一个类似数组的对象。所以他也有length\n\nlet {length : len} = \'hello\';\nlen // 5\n')])])]),e("h3",{attrs:{id:"函数参数的解构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数参数的解构"}},[a._v("#")]),a._v(" 函数参数的解构")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n\n// 基本就是上面几种的应用\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);