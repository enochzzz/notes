(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{555:function(t,a,e){"use strict";e.r(a);var n=e(12),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"let"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[t._v("#")]),t._v(" let")]),t._v(" "),e("ol",[e("li",[t._v('块级作用域。es6引入块级作用域的概念，如下"{}"代码块是块级作用域。')])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{\n  var a = 1;\n  let b = 2;\n}\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("let声明的变量仅在块级作用域内生效")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{\n  var a = 1;\n  let b = 2;\n}\nconsole.log(a); // 1\nconsole.log(b); //  ReferenceError: b is not defined\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("浏览器环境，全局作用域下，var/function 声明变量/方法，会挂载到window全局对象下。而let不会。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var a = 1;\nwindow.a // 1\nlet b = 2;\nwindow.b // undefined\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("不存在变量提升")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("暂时性死区。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("if (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n")])])]),e("ol",{attrs:{start:"6"}},[e("li",[t._v("不能重复声明")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let a\nlet a\n// VM89:2 Uncaught SyntaxError: Identifier 'a' has already been declared\n\nlet ca\nvar ca\n// VM121:2 Uncaught SyntaxError: Identifier 'ca' has already been declared\n\nvar ba\nlet ba\n// VM152:2 Uncaught SyntaxError: Identifier 'ba' has already been declared\n")])])]),e("h3",{attrs:{id:"const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[t._v("#")]),t._v(" const")]),t._v(" "),e("ol",[e("li",[t._v("const声明一个只读的常量。声明后不可修改")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("因为声明后值不能修改，所以const在声明时就必须初始化，即赋值")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const foo;\n// SyntaxError: Missing initializer in const declaration\n\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("const声明的值是引用类型时，需要确保引用不会被改变。如果再此基础上，可以修改他的属性。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('const foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: "foo" is read-only\n')])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("剩余特性都和let一样")])])])}),[],!1,null,null,null);a.default=s.exports}}]);